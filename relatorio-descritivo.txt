Nesse relatório começarei pelo back end da aplicação. 

Escolhi desenvolver o back end em Python, usando o framework Django. A estrutura de um projeto Django é composto por uma pasta que contém as configs gerais do projeto, nesse caso, chamada _core. 
Além dela há pastas individuais para cada app do projeto. Nesse caso, nossos apps são contas, reservas e propriedades.
As models das tabelas podem ser encontrados nos arquivos models.py de cada um desses apps. As rotas nos arquivos views.py. Os arquivos serializers.py são reponsáveis pela validação dos dados antes de sua inserção no banco. 

Focaremos aqui no app contas, nosso principal app. No arquivo views.py desse app há duas classes: uma responsável pelos filtros de contas pedidos no desafio, outra responsável pelas rotas em si. A classe ContaView herda das views genéricas do Django (uma forma prática de se fazer rotas) as rotas post e get. 
No entanto, foi necessário sobrescrever a função post para desenvolver a lógica requerida pelo desafio. Vale a pena passarmos por dois pontos dessa lógica. O primeiro diz respeito à função criar_objs_contas. 
Ela fica no arquivo utils.py (arquivo onde pode-se encontrar diversas funções utilitárias) e é responsável por processar os dados conforme a lógica exigida no ponto 2 da descrição do desafio e retornar uma tupla com dicionários que aí sim serão inseridos no banco de dados. 
Outro ponto digno de nota diz respeito à classe ContaSerializer, encontrada no arquivo serializers.py do app contas. Aqui também foi necessário sobrescrever a função create da classe ModelSerializer para desenvolver a lógica que insere os dados no banco. Essa função é executada duas vezes para cada reserva, para gerar as contas a pagar ou receber, e também faz uso de funções utilitárias de processamento de dados que se encontram no arquivo utils.py. Vale notar que também é nesse serializer que as entradas nos bancos de reservas e de propriedades são feitas. Isso é feito através da função get_or_create do próprio django. Optei por fazer essa lógica dentro do serializer de contas porque assim, com uma única requisição de post na rota /contas/ já são geradas entradas nos bancos de propriedades e reservas, bem como suas respectivas relações. Também vale notar a verificação na linha 44 que impede que sejam criadas duas contas repetidas, evitando duplicações no banco, levantando um erro. Importante: caso nos testes que vocês forem fazer seja necessário rodar mais de uma vez a rota post de contas, é preciso apagar o arquivo db.sqlite3 (apagando assim as entradas de contas) e rodar as migrações novamente (conforme explicado no arquivo README), caso contrário o erro que impede que sejam criadas contas repetidas será lançado.
Finalizando nossa breve explicação sobre o back end da aplicação, vale ainda adicionar que optei por fazer o filtro requerido no ponto 3 com o django-filter. Isso é feito através da url da requisição. No front end há uma função responsável por montar a url para cada requisição de filtragem e será mais explicada adiante. 

Vamos agora ao front da aplicação. 

Optei por desenvolvê-lo com React. Usei também a lib de componentes chakra ui para otimização do desenvolvimento. 
A aplicação possui um header com dois botões e um menu e sob ele um dashboard.
O primeiro botão abre um modal onde se deve fazer o upload do arquivo .csv. 
O processamento desses dados foi feito usando a lib Papa Parse. Essa lógica foi desenvolvida no arquivo ResgisterModal, na pasta Header, na pasta Components, no src do projeto. O retorno do processamento feito pela papaparse é transformado em objetos javascript e então a requisição é feita. Para as requisições no front optei por utilizar a biblioteca axios. Vale lembrar que o grande número de entradas no arquivo enviado para o teste faz com que a requisição demore alguns minutos para se completar, pois para cada conta o DB faz uma série de operações: 1) verifica se já existe ou cria uma propriedade; 2) verifica se existe ou cria uma reserva; 3) verifica se existe aquela conta (se já existe uma exception/erro é lançada); 4) cria e retorna a conta. Caso a requisição falhe o usuário terá um retorno visual por meio de um toast. Portanto, enquanto o spinner de loading estiver na tela, basta esperar. Para acompanhar o andamento do processo é SÓ conferir o terminal em que nosso servidor está rodando (o servidor que foi iniciado com o comando python manage.py runserver), pois deixei alguns prints para retorno visual de cada conta criada.
O segundo botão é responsável pelo ponto 4 do desafio, ele exporta os relatórios das tabelas geradas a partir de requisições get. Esse botão fica desativado até que uma primeira requisição get seja feita. Para o download optei por fazer com a lib react-csv.
As requisições de listagem são feitas nos botões do dropdown menu chamado "Carregar tabela". A opção de filtro abre um modal com três campos, propriedade, data e vencimento onde é possível filtrar as postagens.
Esse filtro foi desenvolvido no arquivo FilterModal.jsx, na pasta Header. A função filterConta é responsável por fazer a montagem da url que será enviada na requisição. Isso foi necessário porque optei por desenvolver o filtro em si no back end com django-filter e ele requer uma url com as informações que se deseja filtrar. O filtro funciona em qualquer combinação, com os três campos, com dois ou somente com um. 
Vale notar também que há retornos visuais dos loadings, bem como toasts diversos que tornam a experiência do usuário na nossa aplicação mais fácil e intuitiva.

Por fim, gostaria de esclarecer que optei por fazer o ponto 3 e 4 juntamente com o bônus do dashboard. O dashboard, portanto, mostra um panorama geral das contas relacionando-as com as reservas, conforme solicitado, mas mostra além das contas a pagar, pois, caso o usuário queira, também pode mostrar as contas a receber. Como os filtros e a exportação são feitos justamente no dashboard que gera uma tabela a partir das requisições feitas, a exportação é completamente customizada em arquivos .csv. Ou seja, é possível exportar os dados de uma tabela a partir de quaisquer combinações dos filtros já mencionados e não apenas conforme indicado no ponto 4, mas, é claro, o abarcando também. 
Quando pensei em como desenvolver a aplicação, achei que seria mais eficiente simplesmente permitir maior possibilidades de ação para o usuário escolher como quer filtrar e a partir desse filtro fazer o download, pois evitaria a repetição de código e o desenvolvimento de filtros separados, segundo o princípio DRY de boas práticas de desenvolvimento, sem deixar de me atentar se os requisitos propostos no desafio estavam sendo cumpridos, evidentemente.

Também fiz a modelagem do banco de dados sugerida como bônus e estou enviando um pdf com o diagrama desenvolvido. Segue abaixo uma breve justificativa das minhas escolhas.
Criei uma tabela para propriedades contendo unicamente o nome encontrado no arquivo .csv de entrada, e um UUID gerado automaticamente. Pensando na escalabilidade vertical da aplicação, penso que essa tabela pode ainda armazenar dados como endereço das propriedades, ou mesmo relacionar-se com outra entidade em que os endereços fiquem armazenados. Portanto, apesar de ter somente um dado para armazenar a princípio, essa tabela é importante.
A tabela de reservas armazena todos os dados contidos no arquivo csv, sem processamento. Embora a tabela de contas seja o foco da aplicação, é importante também salvar todos os dados de entrada em uma tabela específica. 
A tabela de contas tem as colunas tipo, valor, vencimento, propriedade e reserva, sendo essas duas últimas foreign keys responsáveis pela ligação com cada uma das outras duas tabelas. Aqui sim os dados foram processados conforme exigido pelo desafio antes de serem armazenados.
Quanto aos relacionamentos, tanto a partir da tabela de propriedades quanto da tabela de reservas, a relação é "one to many", pois uma propriedade pode estar relacionada a mais de uma conta, bem como uma reserva pode gerar mais de uma conta. Optei também por não fazer uma relação entre Reservas e Propriedades uma vez que o dado inserido na tabela de Reservas que diz respeito à Propriedade é o seu nome, e o dado utilizado pelo sistema para estabelecer relacionamentos é o ID. Seria possível adicionar mais uma coluna na tabela de Reserva para fazer essa relação, mas pensei nessa tabela com a finalidade de armazenar no DB os dados do arquivo .csv de entrada, espécie de backup dos arquivos .csv locais, preservando assim as colunas originais do arquivo, sem adicionar ou subtrair nenhuma. Certamente essa funcionalidade pode ser implementada sem dificuldades, mas me pareceu não fazer sentido, ao menos em um primeiro momento, pensando da perspectiva da aplicação como um todo.

As instruções sobre como rodar a aplicação estão disponíveis no arquivo README.
